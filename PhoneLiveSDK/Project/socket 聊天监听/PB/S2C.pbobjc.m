// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2c.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "S2C.pbobjc.h"
#import "Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AppTopNotice);
GPBObjCClassDeclaration(AppTopNotice_Msg);
GPBObjCClassDeclaration(BuyGuard);
GPBObjCClassDeclaration(BuyGuard_Msg);
GPBObjCClassDeclaration(GiveVideoTicket);
GPBObjCClassDeclaration(GiveVideoTicket_Msg);
GPBObjCClassDeclaration(KickUser);
GPBObjCClassDeclaration(KickUser_Msg);
GPBObjCClassDeclaration(LiveConnect);
GPBObjCClassDeclaration(LiveConnect_Msg);
GPBObjCClassDeclaration(LivePK);
GPBObjCClassDeclaration(LivePK_Msg);
GPBObjCClassDeclaration(LotteryAward);
GPBObjCClassDeclaration(LotteryAward_Msg);
GPBObjCClassDeclaration(LotteryBarrage);
GPBObjCClassDeclaration(LotteryBarrage_Barrage);
GPBObjCClassDeclaration(LotteryBarrage_CTStruct);
GPBObjCClassDeclaration(LotteryBarrage_Msg);
GPBObjCClassDeclaration(LotteryBet);
GPBObjCClassDeclaration(LotteryBet_CTStruct);
GPBObjCClassDeclaration(LotteryBet_Msg);
GPBObjCClassDeclaration(LotteryDividend);
GPBObjCClassDeclaration(LotteryDividend_CTStruct);
GPBObjCClassDeclaration(LotteryDividend_Msg);
GPBObjCClassDeclaration(LotteryOpenAward);
GPBObjCClassDeclaration(LotteryOpenAward_BaiJiaLeStruct);
GPBObjCClassDeclaration(LotteryOpenAward_LongHuStruct);
GPBObjCClassDeclaration(LotteryOpenAward_Msg);
GPBObjCClassDeclaration(LotteryOpenAward_NiuStruct);
GPBObjCClassDeclaration(LotteryOpenAward_ZhaJinHuaStruct);
GPBObjCClassDeclaration(LotteryProfit);
GPBObjCClassDeclaration(LotteryProfit_CTStruct);
GPBObjCClassDeclaration(LotteryProfit_Msg);
GPBObjCClassDeclaration(LotterySync);
GPBObjCClassDeclaration(LotterySync_LotteryInfo);
GPBObjCClassDeclaration(LotterySync_Msg);
GPBObjCClassDeclaration(MoneyChange);
GPBObjCClassDeclaration(MoneyChange_Msg);
GPBObjCClassDeclaration(SendBarrage);
GPBObjCClassDeclaration(SendBarrage_CTStruct);
GPBObjCClassDeclaration(SendBarrage_Msg);
GPBObjCClassDeclaration(SendContactInfo);
GPBObjCClassDeclaration(SendContactInfo_Msg);
GPBObjCClassDeclaration(SendGift);
GPBObjCClassDeclaration(SendGift_GiftInfo);
GPBObjCClassDeclaration(SendGift_Msg);
GPBObjCClassDeclaration(SendMsg);
GPBObjCClassDeclaration(SendMsg_CTStruct);
GPBObjCClassDeclaration(SendMsg_Msg);
GPBObjCClassDeclaration(SendRed);
GPBObjCClassDeclaration(SendRed_Msg);
GPBObjCClassDeclaration(ShutUpUser);
GPBObjCClassDeclaration(ShutUpUser_Msg);
GPBObjCClassDeclaration(StartEndLive);
GPBObjCClassDeclaration(StartEndLive_Msg);
GPBObjCClassDeclaration(SystemNot);
GPBObjCClassDeclaration(SystemNot_Msg);
GPBObjCClassDeclaration(TranslateContent);
GPBObjCClassDeclaration(TranslateContent_Msg);
GPBObjCClassDeclaration(changeLive);
GPBObjCClassDeclaration(changeLive_Msg);
GPBObjCClassDeclaration(disconnect);
GPBObjCClassDeclaration(disconnect_CTStruct);
GPBObjCClassDeclaration(disconnect_Msg);
GPBObjCClassDeclaration(kyGame);
GPBObjCClassDeclaration(kyGame_Msg);
GPBObjCClassDeclaration(light);
GPBObjCClassDeclaration(light_Msg);
GPBObjCClassDeclaration(platGame);
GPBObjCClassDeclaration(platGame_Msg);
GPBObjCClassDeclaration(requestFans);
GPBObjCClassDeclaration(requestFans_Fans);
GPBObjCClassDeclaration(requestFans_InfoStruct);
GPBObjCClassDeclaration(requestFans_Msg);
GPBObjCClassDeclaration(requestFans_UserInfo);
GPBObjCClassDeclaration(setAdmin);
GPBObjCClassDeclaration(setAdmin_Msg);
GPBObjCClassDeclaration(stopLive);
GPBObjCClassDeclaration(stopLive_Msg);
GPBObjCClassDeclaration(updateVotes);
GPBObjCClassDeclaration(updateVotes_Msg);

#pragma mark - S2CRoot

@implementation S2CRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - S2CRoot_FileDescriptor

static GPBFileDescriptor *S2CRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"s2c"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - SystemNot

@implementation SystemNot

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct SystemNot__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  SystemNot_Msg *msg;
} SystemNot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = SystemNot_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemNot__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = SystemNot_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemNot__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(SystemNot_Msg),
        .number = SystemNot_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemNot__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemNot class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemNot__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemNot_Msg

@implementation SystemNot_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasUname, uname;
@dynamic hasMsgtype, msgtype;

typedef struct SystemNot_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  NSString *ct;
  NSString *uname;
} SystemNot_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = SystemNot_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemNot_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = SystemNot_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemNot_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = SystemNot_Msg_FieldNumber_Uname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemNot_Msg__storage_, uname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = SystemNot_Msg_FieldNumber_Msgtype,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SystemNot_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemNot_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemNot_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SystemNot)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LiveConnect

@implementation LiveConnect

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct LiveConnect__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  LiveConnect_Msg *msg;
} LiveConnect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConnect_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LiveConnect__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConnect_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LiveConnect__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConnect_Msg),
        .number = LiveConnect_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LiveConnect__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LiveConnect class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LiveConnect__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LiveConnect_Msg

@implementation LiveConnect_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasPkuid, pkuid;
@dynamic hasPkpull, pkpull;
@dynamic hasUid, uid;
@dynamic hasUname, uname;

typedef struct LiveConnect_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t pkuid;
  uint32_t uid;
  NSString *pkpull;
  NSString *uname;
} LiveConnect_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConnect_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LiveConnect_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConnect_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LiveConnect_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pkuid",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConnect_Msg_FieldNumber_Pkuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LiveConnect_Msg__storage_, pkuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pkpull",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConnect_Msg_FieldNumber_Pkpull,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LiveConnect_Msg__storage_, pkpull),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConnect_Msg_FieldNumber_Uid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LiveConnect_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConnect_Msg_FieldNumber_Uname,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LiveConnect_Msg__storage_, uname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LiveConnect_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LiveConnect_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LiveConnect)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LivePK

@implementation LivePK

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct LivePK__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  LivePK_Msg *msg;
} LivePK__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = LivePK_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LivePK__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LivePK_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LivePK__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(LivePK_Msg),
        .number = LivePK_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LivePK__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LivePK class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LivePK__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LivePK_Msg

@implementation LivePK_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasPkuid, pkuid;
@dynamic hasUid, uid;
@dynamic hasUname, uname;

typedef struct LivePK_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t pkuid;
  uint32_t uid;
  NSString *uname;
} LivePK_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = LivePK_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LivePK_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = LivePK_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LivePK_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pkuid",
        .dataTypeSpecific.clazz = Nil,
        .number = LivePK_Msg_FieldNumber_Pkuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LivePK_Msg__storage_, pkuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = LivePK_Msg_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LivePK_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = LivePK_Msg_FieldNumber_Uname,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LivePK_Msg__storage_, uname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LivePK_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LivePK_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LivePK)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - requestFans

@implementation requestFans

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct requestFans__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  requestFans_Msg *msg;
} requestFans__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(requestFans__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(requestFans__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(requestFans_Msg),
        .number = requestFans_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(requestFans__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[requestFans class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(requestFans__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - requestFans_UserInfo

@implementation requestFans_UserInfo

@dynamic hasId_p, id_p;
@dynamic hasAvatar, avatar;
@dynamic hasGuardType, guardType;
@dynamic hasLevel, level;

typedef struct requestFans_UserInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  uint32_t guardType;
  uint32_t level;
  NSString *avatar;
} requestFans_UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_UserInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(requestFans_UserInfo__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_UserInfo_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(requestFans_UserInfo__storage_, avatar),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "guardType",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_UserInfo_FieldNumber_GuardType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(requestFans_UserInfo__storage_, guardType),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_UserInfo_FieldNumber_Level,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(requestFans_UserInfo__storage_, level),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[requestFans_UserInfo class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(requestFans_UserInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(requestFans)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - requestFans_InfoStruct

@implementation requestFans_InfoStruct

@dynamic listArray, listArray_Count;

typedef struct requestFans_InfoStruct__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} requestFans_InfoStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.clazz = GPBObjCClass(requestFans_UserInfo),
        .number = requestFans_InfoStruct_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(requestFans_InfoStruct__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[requestFans_InfoStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(requestFans_InfoStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(requestFans)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - requestFans_Fans

@implementation requestFans_Fans

@dynamic hasCode, code;
@dynamic hasInfo, info;
@dynamic hasMsg, msg;

typedef struct requestFans_Fans__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  requestFans_InfoStruct *info;
  NSString *msg;
} requestFans_Fans__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_Fans_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(requestFans_Fans__storage_, code),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(requestFans_InfoStruct),
        .number = requestFans_Fans_FieldNumber_Info,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(requestFans_Fans__storage_, info),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_Fans_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(requestFans_Fans__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[requestFans_Fans class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(requestFans_Fans__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(requestFans)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - requestFans_Msg

@implementation requestFans_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasCt, ct;

typedef struct requestFans_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  requestFans_Fans *ct;
} requestFans_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(requestFans_Msg__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = requestFans_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(requestFans_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = GPBObjCClass(requestFans_Fans),
        .number = requestFans_Msg_FieldNumber_Ct,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(requestFans_Msg__storage_, ct),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[requestFans_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(requestFans_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(requestFans)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsg

@implementation SendMsg

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct SendMsg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  SendMsg_Msg *msg;
} SendMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsg__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMsg__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(SendMsg_Msg),
        .number = SendMsg_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendMsg__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsg_CTStruct

@implementation SendMsg_CTStruct

@dynamic hasId_p, id_p;
@dynamic hasUserNicename, userNicename;
@dynamic hasAvatar, avatar;
@dynamic hasAvatarThumb, avatarThumb;
@dynamic hasLevel, level;
@dynamic hasUsertype, usertype;
@dynamic hasVipType, vipType;
@dynamic hasGuardType, guardType;
@dynamic hasLiangname, liangname;
@dynamic hasCarId, carId;
@dynamic hasCarSwf, carSwf;
@dynamic hasCarSwftime, carSwftime;
@dynamic hasCarWords, carWords;
@dynamic hasIsAnchor, isAnchor;
@dynamic hasHeart, heart;
@dynamic hasKingIcon, kingIcon;

typedef struct SendMsg_CTStruct__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  uint32_t level;
  uint32_t usertype;
  uint32_t vipType;
  uint32_t guardType;
  uint32_t carId;
  NSString *userNicename;
  NSString *avatar;
  NSString *avatarThumb;
  NSString *liangname;
  NSString *carSwf;
  NSString *carSwftime;
  NSString *carWords;
  NSString *heart;
  NSString *kingIcon;
} SendMsg_CTStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userNicename",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_UserNicename,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, userNicename),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarThumb",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_AvatarThumb,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, avatarThumb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_Level,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, level),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "usertype",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_Usertype,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, usertype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "vipType",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_VipType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, vipType),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "guardType",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_GuardType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, guardType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "liangname",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_Liangname,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, liangname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "carId",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_CarId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, carId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "carSwf",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_CarSwf,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, carSwf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "carSwftime",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_CarSwftime,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, carSwftime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "carWords",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_CarWords,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, carWords),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAnchor",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_IsAnchor,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "heart",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_Heart,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, heart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "kingIcon",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_CTStruct_FieldNumber_KingIcon,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(SendMsg_CTStruct__storage_, kingIcon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsg_CTStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsg_CTStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\016\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SendMsg)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsg_Msg

@implementation SendMsg_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasContent, content;
@dynamic hasUname, uname;
@dynamic hasLang, lang;

typedef struct SendMsg_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  SendMsg_CTStruct *ct;
  NSString *content;
  NSString *uname;
  NSString *lang;
} SendMsg_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsg_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = GPBObjCClass(SendMsg_CTStruct),
        .number = SendMsg_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMsg_Msg__storage_, ct),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendMsg_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_Msg_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendMsg_Msg__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_Msg_FieldNumber_Uname,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendMsg_Msg__storage_, uname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lang",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsg_Msg_FieldNumber_Lang,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendMsg_Msg__storage_, lang),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsg_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsg_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SendMsg)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StartEndLive

@implementation StartEndLive

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct StartEndLive__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  StartEndLive_Msg *msg;
} StartEndLive__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = StartEndLive_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StartEndLive__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = StartEndLive_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StartEndLive__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(StartEndLive_Msg),
        .number = StartEndLive_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StartEndLive__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StartEndLive class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StartEndLive__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StartEndLive_Msg

@implementation StartEndLive_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasUname, uname;
@dynamic hasMsgtype, msgtype;

typedef struct StartEndLive_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  NSString *ct;
  NSString *uname;
} StartEndLive_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = StartEndLive_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StartEndLive_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = StartEndLive_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StartEndLive_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = StartEndLive_Msg_FieldNumber_Uname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StartEndLive_Msg__storage_, uname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = StartEndLive_Msg_FieldNumber_Msgtype,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StartEndLive_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StartEndLive_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StartEndLive_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(StartEndLive)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - disconnect

@implementation disconnect

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct disconnect__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  disconnect_Msg *msg;
} disconnect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(disconnect__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(disconnect__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(disconnect_Msg),
        .number = disconnect_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(disconnect__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[disconnect class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(disconnect__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - disconnect_CTStruct

@implementation disconnect_CTStruct

@dynamic hasId_p, id_p;
@dynamic hasUserNicename, userNicename;
@dynamic hasAvatar, avatar;
@dynamic hasLevel, level;

typedef struct disconnect_CTStruct__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  uint32_t level;
  NSString *userNicename;
  NSString *avatar;
} disconnect_CTStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_CTStruct_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(disconnect_CTStruct__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userNicename",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_CTStruct_FieldNumber_UserNicename,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(disconnect_CTStruct__storage_, userNicename),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_CTStruct_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(disconnect_CTStruct__storage_, avatar),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_CTStruct_FieldNumber_Level,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(disconnect_CTStruct__storage_, level),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[disconnect_CTStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(disconnect_CTStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(disconnect)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - disconnect_Msg

@implementation disconnect_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasUid, uid;
@dynamic hasUname, uname;
@dynamic hasMsgtype, msgtype;

typedef struct disconnect_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t uid;
  uint32_t msgtype;
  disconnect_CTStruct *ct;
  NSString *uname;
} disconnect_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(disconnect_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = GPBObjCClass(disconnect_CTStruct),
        .number = disconnect_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(disconnect_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_Msg_FieldNumber_Uid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(disconnect_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_Msg_FieldNumber_Uname,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(disconnect_Msg__storage_, uname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = disconnect_Msg_FieldNumber_Msgtype,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(disconnect_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[disconnect_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(disconnect_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(disconnect)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - kyGame

@implementation kyGame

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct kyGame__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  kyGame_Msg *msg;
} kyGame__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = kyGame_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(kyGame__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = kyGame_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(kyGame__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(kyGame_Msg),
        .number = kyGame_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(kyGame__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[kyGame class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(kyGame__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - kyGame_Msg

@implementation kyGame_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasGamePlat, gamePlat;
@dynamic hasGameKindId, gameKindId;

typedef struct kyGame_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t gameKindId;
  NSString *ct;
  NSString *gamePlat;
} kyGame_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = kyGame_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(kyGame_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = kyGame_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(kyGame_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = kyGame_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(kyGame_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gamePlat",
        .dataTypeSpecific.clazz = Nil,
        .number = kyGame_Msg_FieldNumber_GamePlat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(kyGame_Msg__storage_, gamePlat),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameKindId",
        .dataTypeSpecific.clazz = Nil,
        .number = kyGame_Msg_FieldNumber_GameKindId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(kyGame_Msg__storage_, gameKindId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[kyGame_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(kyGame_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\010\000\005\tA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(kyGame)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - platGame

@implementation platGame

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct platGame__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  platGame_Msg *msg;
} platGame__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = platGame_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(platGame__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = platGame_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(platGame__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(platGame_Msg),
        .number = platGame_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(platGame__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[platGame class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(platGame__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - platGame_Msg

@implementation platGame_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasGamePlat, gamePlat;
@dynamic hasGameKindId, gameKindId;
@dynamic hasExt1, ext1;

typedef struct platGame_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  NSString *ct;
  NSString *gamePlat;
  NSString *gameKindId;
  NSString *ext1;
} platGame_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = platGame_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(platGame_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = platGame_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(platGame_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = platGame_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(platGame_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gamePlat",
        .dataTypeSpecific.clazz = Nil,
        .number = platGame_Msg_FieldNumber_GamePlat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(platGame_Msg__storage_, gamePlat),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameKindId",
        .dataTypeSpecific.clazz = Nil,
        .number = platGame_Msg_FieldNumber_GameKindId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(platGame_Msg__storage_, gameKindId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext1",
        .dataTypeSpecific.clazz = Nil,
        .number = platGame_Msg_FieldNumber_Ext1,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(platGame_Msg__storage_, ext1),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[platGame_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(platGame_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\010\000\005\tA\000\006\003\201\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(platGame)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TranslateContent

@implementation TranslateContent

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct TranslateContent__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  TranslateContent_Msg *msg;
} TranslateContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = TranslateContent_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TranslateContent__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = TranslateContent_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TranslateContent__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(TranslateContent_Msg),
        .number = TranslateContent_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TranslateContent__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TranslateContent class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TranslateContent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TranslateContent_Msg

@implementation TranslateContent_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasContent, content;

typedef struct TranslateContent_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  NSString *ct;
  NSString *content;
} TranslateContent_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = TranslateContent_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TranslateContent_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = TranslateContent_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TranslateContent_Msg__storage_, ct),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = TranslateContent_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TranslateContent_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = TranslateContent_Msg_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TranslateContent_Msg__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TranslateContent_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TranslateContent_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(TranslateContent)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GiveVideoTicket

@implementation GiveVideoTicket

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct GiveVideoTicket__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  GiveVideoTicket_Msg *msg;
} GiveVideoTicket__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = GiveVideoTicket_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GiveVideoTicket__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = GiveVideoTicket_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GiveVideoTicket__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(GiveVideoTicket_Msg),
        .number = GiveVideoTicket_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GiveVideoTicket__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GiveVideoTicket class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GiveVideoTicket__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GiveVideoTicket_Msg

@implementation GiveVideoTicket_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasTicketNum, ticketNum;

typedef struct GiveVideoTicket_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t ticketNum;
  NSString *ct;
} GiveVideoTicket_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = GiveVideoTicket_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GiveVideoTicket_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = GiveVideoTicket_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GiveVideoTicket_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = GiveVideoTicket_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GiveVideoTicket_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ticketNum",
        .dataTypeSpecific.clazz = Nil,
        .number = GiveVideoTicket_Msg_FieldNumber_TicketNum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GiveVideoTicket_Msg__storage_, ticketNum),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GiveVideoTicket_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GiveVideoTicket_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GiveVideoTicket)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryAward

@implementation LotteryAward

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct LotteryAward__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  LotteryAward_Msg *msg;
} LotteryAward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryAward_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryAward__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryAward_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryAward__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryAward_Msg),
        .number = LotteryAward_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryAward__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryAward class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryAward__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryAward_Msg

@implementation LotteryAward_Msg

@dynamic hasAction, action;
@dynamic hasAwardMoney, awardMoney;
@dynamic hasMsgtype, msgtype;

typedef struct LotteryAward_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  float awardMoney;
  uint32_t msgtype;
} LotteryAward_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryAward_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryAward_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "awardMoney",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryAward_Msg_FieldNumber_AwardMoney,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryAward_Msg__storage_, awardMoney),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryAward_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryAward_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryAward_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryAward_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryAward)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryBarrage

@implementation LotteryBarrage

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct LotteryBarrage__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  LotteryBarrage_Msg *msg;
} LotteryBarrage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryBarrage__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryBarrage__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryBarrage_Msg),
        .number = LotteryBarrage_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryBarrage__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryBarrage class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryBarrage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryBarrage_CTStruct

@implementation LotteryBarrage_CTStruct

@dynamic hasNickname, nickname;
@dynamic hasLotteryName, lotteryName;
@dynamic hasWay, way;
@dynamic hasTotalmoney, totalmoney;
@dynamic hasShowType, showType;

typedef struct LotteryBarrage_CTStruct__storage_ {
  uint32_t _has_storage_[1];
  uint32_t showType;
  NSString *nickname;
  NSString *lotteryName;
  NSString *way;
  NSString *totalmoney;
} LotteryBarrage_CTStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nickname",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_CTStruct_FieldNumber_Nickname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryBarrage_CTStruct__storage_, nickname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lotteryName",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_CTStruct_FieldNumber_LotteryName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryBarrage_CTStruct__storage_, lotteryName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "way",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_CTStruct_FieldNumber_Way,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryBarrage_CTStruct__storage_, way),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalmoney",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_CTStruct_FieldNumber_Totalmoney,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotteryBarrage_CTStruct__storage_, totalmoney),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "showType",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_CTStruct_FieldNumber_ShowType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LotteryBarrage_CTStruct__storage_, showType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryBarrage_CTStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryBarrage_CTStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\013\000\005\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryBarrage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryBarrage_Barrage

@implementation LotteryBarrage_Barrage

@dynamic hasCt, ct;
@dynamic hasLt, lt;
@dynamic hasLid, lid;
@dynamic hasSt, st;

typedef struct LotteryBarrage_Barrage__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lt;
  uint32_t lid;
  uint32_t st;
  LotteryBarrage_CTStruct *ct;
} LotteryBarrage_Barrage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ct",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryBarrage_CTStruct),
        .number = LotteryBarrage_Barrage_FieldNumber_Ct,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryBarrage_Barrage__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_Barrage_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryBarrage_Barrage__storage_, lt),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lid",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_Barrage_FieldNumber_Lid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryBarrage_Barrage__storage_, lid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "st",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_Barrage_FieldNumber_St,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotteryBarrage_Barrage__storage_, st),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryBarrage_Barrage class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryBarrage_Barrage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryBarrage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryBarrage_Msg

@implementation LotteryBarrage_Msg

@dynamic hasAction, action;
@dynamic barrageArrArray, barrageArrArray_Count;
@dynamic hasMsgtype, msgtype;

typedef struct LotteryBarrage_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  NSMutableArray *barrageArrArray;
} LotteryBarrage_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryBarrage_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "barrageArrArray",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryBarrage_Barrage),
        .number = LotteryBarrage_Msg_FieldNumber_BarrageArrArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LotteryBarrage_Msg__storage_, barrageArrArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBarrage_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryBarrage_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryBarrage_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryBarrage_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryBarrage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryBet

@implementation LotteryBet

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct LotteryBet__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  LotteryBet_Msg *msg;
} LotteryBet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryBet__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryBet__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryBet_Msg),
        .number = LotteryBet_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryBet__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryBet class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryBet__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryBet_CTStruct

@implementation LotteryBet_CTStruct

@dynamic hasNickname, nickname;
@dynamic hasLotteryName, lotteryName;
@dynamic hasTotalmoney, totalmoney;

typedef struct LotteryBet_CTStruct__storage_ {
  uint32_t _has_storage_[1];
  NSString *nickname;
  NSString *lotteryName;
  NSString *totalmoney;
} LotteryBet_CTStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nickname",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_CTStruct_FieldNumber_Nickname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryBet_CTStruct__storage_, nickname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lotteryName",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_CTStruct_FieldNumber_LotteryName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryBet_CTStruct__storage_, lotteryName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalmoney",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_CTStruct_FieldNumber_Totalmoney,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryBet_CTStruct__storage_, totalmoney),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryBet_CTStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryBet_CTStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryBet)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryBet_Msg

@implementation LotteryBet_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasLotteryType, lotteryType;
@dynamic hasOptionName, optionName;
@dynamic hasWay, way;
@dynamic hasMoney, money;
@dynamic hasIssue, issue;
@dynamic hasOptionNameSt, optionNameSt;
@dynamic hasWaySt, waySt;
@dynamic hasUid, uid;
@dynamic hasChatSelfShow, chatSelfShow;

typedef struct LotteryBet_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t lotteryType;
  uint32_t uid;
  LotteryBet_CTStruct *ct;
  NSString *optionName;
  NSString *way;
  NSString *money;
  NSString *optionNameSt;
  NSString *waySt;
  uint64_t issue;
} LotteryBet_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryBet_CTStruct),
        .number = LotteryBet_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lotteryType",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_LotteryType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, lotteryType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "optionName",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_OptionName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, optionName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "way",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_Way,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, way),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "money",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_Money,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, money),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "issue",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_Issue,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, issue),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "optionNameSt",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_OptionNameSt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, optionNameSt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "waySt",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_WaySt,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, waySt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_Uid,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LotteryBet_Msg__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chatSelfShow",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryBet_Msg_FieldNumber_ChatSelfShow,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryBet_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryBet_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\013\000\005\n\000\t\n\242\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryBet)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryOpenAward

@implementation LotteryOpenAward

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct LotteryOpenAward__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  LotteryOpenAward_Msg *msg;
} LotteryOpenAward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryOpenAward__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryOpenAward__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryOpenAward_Msg),
        .number = LotteryOpenAward_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryOpenAward__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryOpenAward class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryOpenAward__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryOpenAward_NiuStruct

@implementation LotteryOpenAward_NiuStruct

@dynamic hasRedNiu, redNiu;
@dynamic hasBlueNiu, blueNiu;

typedef struct LotteryOpenAward_NiuStruct__storage_ {
  uint32_t _has_storage_[1];
  NSString *redNiu;
  NSString *blueNiu;
} LotteryOpenAward_NiuStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redNiu",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_NiuStruct_FieldNumber_RedNiu,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryOpenAward_NiuStruct__storage_, redNiu),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blueNiu",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_NiuStruct_FieldNumber_BlueNiu,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryOpenAward_NiuStruct__storage_, blueNiu),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryOpenAward_NiuStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryOpenAward_NiuStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryOpenAward)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryOpenAward_BaiJiaLeStruct

@implementation LotteryOpenAward_BaiJiaLeStruct

@dynamic hasZhuangDian, zhuangDian;
@dynamic hasXianDian, xianDian;
@dynamic hasZhuangDianStr, zhuangDianStr;
@dynamic hasXianDianStr, xianDianStr;
@dynamic hasWhoWin, whoWin;
@dynamic hasZhuangxianStr, zhuangxianStr;

typedef struct LotteryOpenAward_BaiJiaLeStruct__storage_ {
  uint32_t _has_storage_[1];
  uint32_t zhuangDian;
  uint32_t xianDian;
  uint32_t whoWin;
  NSString *zhuangDianStr;
  NSString *xianDianStr;
  NSString *zhuangxianStr;
} LotteryOpenAward_BaiJiaLeStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "zhuangDian",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_BaiJiaLeStruct_FieldNumber_ZhuangDian,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryOpenAward_BaiJiaLeStruct__storage_, zhuangDian),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "xianDian",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_BaiJiaLeStruct_FieldNumber_XianDian,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryOpenAward_BaiJiaLeStruct__storage_, xianDian),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "zhuangDianStr",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_BaiJiaLeStruct_FieldNumber_ZhuangDianStr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryOpenAward_BaiJiaLeStruct__storage_, zhuangDianStr),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "xianDianStr",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_BaiJiaLeStruct_FieldNumber_XianDianStr,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotteryOpenAward_BaiJiaLeStruct__storage_, xianDianStr),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "whoWin",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_BaiJiaLeStruct_FieldNumber_WhoWin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LotteryOpenAward_BaiJiaLeStruct__storage_, whoWin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "zhuangxianStr",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_BaiJiaLeStruct_FieldNumber_ZhuangxianStr,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LotteryOpenAward_BaiJiaLeStruct__storage_, zhuangxianStr),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryOpenAward_BaiJiaLeStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryOpenAward_BaiJiaLeStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryOpenAward)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryOpenAward_ZhaJinHuaStruct

@implementation LotteryOpenAward_ZhaJinHuaStruct

@dynamic hasWhoWin, whoWin;
@dynamic paiTypeArray, paiTypeArray_Count;
@dynamic paiTypeStrArray, paiTypeStrArray_Count;

typedef struct LotteryOpenAward_ZhaJinHuaStruct__storage_ {
  uint32_t _has_storage_[1];
  uint32_t whoWin;
  GPBUInt32Array *paiTypeArray;
  NSMutableArray *paiTypeStrArray;
} LotteryOpenAward_ZhaJinHuaStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "whoWin",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_ZhaJinHuaStruct_FieldNumber_WhoWin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryOpenAward_ZhaJinHuaStruct__storage_, whoWin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "paiTypeArray",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_ZhaJinHuaStruct_FieldNumber_PaiTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LotteryOpenAward_ZhaJinHuaStruct__storage_, paiTypeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "paiTypeStrArray",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_ZhaJinHuaStruct_FieldNumber_PaiTypeStrArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LotteryOpenAward_ZhaJinHuaStruct__storage_, paiTypeStrArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryOpenAward_ZhaJinHuaStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryOpenAward_ZhaJinHuaStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryOpenAward)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryOpenAward_LongHuStruct

@implementation LotteryOpenAward_LongHuStruct

@dynamic hasWhoWin, whoWin;
@dynamic hasDragonDian, dragonDian;
@dynamic hasDragonDianStr, dragonDianStr;
@dynamic hasTigerDian, tigerDian;
@dynamic hasTigerDianStr, tigerDianStr;
@dynamic hasDragonTigerStr, dragonTigerStr;

typedef struct LotteryOpenAward_LongHuStruct__storage_ {
  uint32_t _has_storage_[1];
  uint32_t whoWin;
  uint32_t dragonDian;
  uint32_t tigerDian;
  NSString *dragonDianStr;
  NSString *tigerDianStr;
  NSString *dragonTigerStr;
} LotteryOpenAward_LongHuStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "whoWin",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_LongHuStruct_FieldNumber_WhoWin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryOpenAward_LongHuStruct__storage_, whoWin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dragonDian",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_LongHuStruct_FieldNumber_DragonDian,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryOpenAward_LongHuStruct__storage_, dragonDian),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dragonDianStr",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_LongHuStruct_FieldNumber_DragonDianStr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryOpenAward_LongHuStruct__storage_, dragonDianStr),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tigerDian",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_LongHuStruct_FieldNumber_TigerDian,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotteryOpenAward_LongHuStruct__storage_, tigerDian),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tigerDianStr",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_LongHuStruct_FieldNumber_TigerDianStr,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LotteryOpenAward_LongHuStruct__storage_, tigerDianStr),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dragonTigerStr",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_LongHuStruct_FieldNumber_DragonTigerStr,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LotteryOpenAward_LongHuStruct__storage_, dragonTigerStr),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryOpenAward_LongHuStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryOpenAward_LongHuStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryOpenAward)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryOpenAward_Msg

@implementation LotteryOpenAward_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasLotteryType, lotteryType;
@dynamic hasResult, result;
@dynamic hasName, name;
@dynamic hasIssue, issue;
@dynamic hasSumResultStr, sumResultStr;
@dynamic hasNiu, niu;
@dynamic winWaysArray, winWaysArray_Count;
@dynamic hasBjl, bjl;
@dynamic hasZjh, zjh;
@dynamic hasLh, lh;

typedef struct LotteryOpenAward_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t lotteryType;
  NSString *ct;
  NSString *result;
  NSString *name;
  NSString *sumResultStr;
  LotteryOpenAward_NiuStruct *niu;
  NSMutableArray *winWaysArray;
  LotteryOpenAward_BaiJiaLeStruct *bjl;
  LotteryOpenAward_ZhaJinHuaStruct *zjh;
  LotteryOpenAward_LongHuStruct *lh;
  uint64_t issue;
} LotteryOpenAward_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lotteryType",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_Msg_FieldNumber_LotteryType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, lotteryType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "result",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_Msg_FieldNumber_Result,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, result),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_Msg_FieldNumber_Name,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "issue",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_Msg_FieldNumber_Issue,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, issue),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "sumResultStr",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_Msg_FieldNumber_SumResultStr,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, sumResultStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "niu",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryOpenAward_NiuStruct),
        .number = LotteryOpenAward_Msg_FieldNumber_Niu,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, niu),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "winWaysArray",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryOpenAward_Msg_FieldNumber_WinWaysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, winWaysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bjl",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryOpenAward_BaiJiaLeStruct),
        .number = LotteryOpenAward_Msg_FieldNumber_Bjl,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, bjl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "zjh",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryOpenAward_ZhaJinHuaStruct),
        .number = LotteryOpenAward_Msg_FieldNumber_Zjh,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, zjh),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lh",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryOpenAward_LongHuStruct),
        .number = LotteryOpenAward_Msg_FieldNumber_Lh,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(LotteryOpenAward_Msg__storage_, lh),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryOpenAward_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryOpenAward_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\013\000\n\000winWays\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryOpenAward)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryDividend

@implementation LotteryDividend

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct LotteryDividend__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  LotteryDividend_Msg *msg;
} LotteryDividend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryDividend__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryDividend__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryDividend_Msg),
        .number = LotteryDividend_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryDividend__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryDividend class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryDividend__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryDividend_CTStruct

@implementation LotteryDividend_CTStruct

@dynamic hasNickname, nickname;
@dynamic hasLotteryName, lotteryName;
@dynamic hasTotalmoney, totalmoney;
@dynamic hasFromName, fromName;

typedef struct LotteryDividend_CTStruct__storage_ {
  uint32_t _has_storage_[1];
  NSString *nickname;
  NSString *lotteryName;
  NSString *totalmoney;
  NSString *fromName;
} LotteryDividend_CTStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nickname",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_CTStruct_FieldNumber_Nickname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryDividend_CTStruct__storage_, nickname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lotteryName",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_CTStruct_FieldNumber_LotteryName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryDividend_CTStruct__storage_, lotteryName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalmoney",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_CTStruct_FieldNumber_Totalmoney,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryDividend_CTStruct__storage_, totalmoney),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromName",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_CTStruct_FieldNumber_FromName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotteryDividend_CTStruct__storage_, fromName),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryDividend_CTStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryDividend_CTStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryDividend)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryDividend_Msg

@implementation LotteryDividend_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasFromUid, fromUid;
@dynamic hasFromName, fromName;

typedef struct LotteryDividend_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t fromUid;
  LotteryDividend_CTStruct *ct;
  NSString *fromName;
} LotteryDividend_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryDividend_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryDividend_CTStruct),
        .number = LotteryDividend_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryDividend_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryDividend_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fromUid",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_Msg_FieldNumber_FromUid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotteryDividend_Msg__storage_, fromUid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fromName",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryDividend_Msg_FieldNumber_FromName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LotteryDividend_Msg__storage_, fromName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryDividend_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryDividend_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryDividend)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MoneyChange

@implementation MoneyChange

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct MoneyChange__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  MoneyChange_Msg *msg;
} MoneyChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = MoneyChange_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MoneyChange__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = MoneyChange_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MoneyChange__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(MoneyChange_Msg),
        .number = MoneyChange_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MoneyChange__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MoneyChange class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MoneyChange__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MoneyChange_Msg

@implementation MoneyChange_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasIssue, issue;
@dynamic hasMoney, money;

typedef struct MoneyChange_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  float money;
  NSString *ct;
  uint64_t issue;
} MoneyChange_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = MoneyChange_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MoneyChange_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = MoneyChange_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MoneyChange_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = MoneyChange_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MoneyChange_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "issue",
        .dataTypeSpecific.clazz = Nil,
        .number = MoneyChange_Msg_FieldNumber_Issue,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MoneyChange_Msg__storage_, issue),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "money",
        .dataTypeSpecific.clazz = Nil,
        .number = MoneyChange_Msg_FieldNumber_Money,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MoneyChange_Msg__storage_, money),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MoneyChange_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MoneyChange_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(MoneyChange)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryProfit

@implementation LotteryProfit

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct LotteryProfit__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  LotteryProfit_Msg *msg;
} LotteryProfit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryProfit_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryProfit__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryProfit_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryProfit__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryProfit_Msg),
        .number = LotteryProfit_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryProfit__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryProfit class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryProfit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryProfit_CTStruct

@implementation LotteryProfit_CTStruct

@dynamic hasNickname, nickname;
@dynamic hasLotteryName, lotteryName;

typedef struct LotteryProfit_CTStruct__storage_ {
  uint32_t _has_storage_[1];
  NSString *nickname;
  NSString *lotteryName;
} LotteryProfit_CTStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nickname",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryProfit_CTStruct_FieldNumber_Nickname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryProfit_CTStruct__storage_, nickname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lotteryName",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryProfit_CTStruct_FieldNumber_LotteryName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryProfit_CTStruct__storage_, lotteryName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryProfit_CTStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryProfit_CTStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryProfit)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotteryProfit_Msg

@implementation LotteryProfit_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasUid, uid;
@dynamic hasWinWay, winWay;
@dynamic hasProfit, profit;

typedef struct LotteryProfit_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t uid;
  uint32_t profit;
  LotteryProfit_CTStruct *ct;
  NSString *winWay;
} LotteryProfit_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryProfit_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotteryProfit_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = GPBObjCClass(LotteryProfit_CTStruct),
        .number = LotteryProfit_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotteryProfit_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryProfit_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotteryProfit_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryProfit_Msg_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotteryProfit_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "winWay",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryProfit_Msg_FieldNumber_WinWay,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LotteryProfit_Msg__storage_, winWay),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "profit",
        .dataTypeSpecific.clazz = Nil,
        .number = LotteryProfit_Msg_FieldNumber_Profit,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LotteryProfit_Msg__storage_, profit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotteryProfit_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotteryProfit_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotteryProfit)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotterySync

@implementation LotterySync

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct LotterySync__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  LotterySync_Msg *msg;
} LotterySync__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotterySync__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotterySync__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(LotterySync_Msg),
        .number = LotterySync_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotterySync__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotterySync class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotterySync__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotterySync_LotteryInfo

@implementation LotterySync_LotteryInfo

@dynamic hasName, name;
@dynamic hasLogo, logo;
@dynamic hasTime, time;
@dynamic hasSealingTim, sealingTim;
@dynamic hasIssue, issue;
@dynamic hasStopOrSell, stopOrSell;
@dynamic hasStopMsg, stopMsg;
@dynamic hasLotteryType, lotteryType;
@dynamic hasSerTime, serTime;

typedef struct LotterySync_LotteryInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t time;
  uint32_t sealingTim;
  uint32_t stopOrSell;
  uint32_t lotteryType;
  uint32_t serTime;
  NSString *name;
  NSString *logo;
  NSString *stopMsg;
  uint64_t issue;
} LotterySync_LotteryInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_LotteryInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotterySync_LotteryInfo__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logo",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_LotteryInfo_FieldNumber_Logo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotterySync_LotteryInfo__storage_, logo),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_LotteryInfo_FieldNumber_Time,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotterySync_LotteryInfo__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sealingTim",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_LotteryInfo_FieldNumber_SealingTim,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotterySync_LotteryInfo__storage_, sealingTim),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "issue",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_LotteryInfo_FieldNumber_Issue,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LotterySync_LotteryInfo__storage_, issue),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "stopOrSell",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_LotteryInfo_FieldNumber_StopOrSell,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LotterySync_LotteryInfo__storage_, stopOrSell),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "stopMsg",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_LotteryInfo_FieldNumber_StopMsg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LotterySync_LotteryInfo__storage_, stopMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lotteryType",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_LotteryInfo_FieldNumber_LotteryType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LotterySync_LotteryInfo__storage_, lotteryType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serTime",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_LotteryInfo_FieldNumber_SerTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LotterySync_LotteryInfo__storage_, serTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotterySync_LotteryInfo class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotterySync_LotteryInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\004\n\000\006\n\000\007\007\000\010\013\000\t\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotterySync)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LotterySync_Msg

@implementation LotterySync_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasLotteryType, lotteryType;
@dynamic hasLotteryInfo, lotteryInfo;

typedef struct LotterySync_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t lotteryType;
  NSString *ct;
  LotterySync_LotteryInfo *lotteryInfo;
} LotterySync_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LotterySync_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LotterySync_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LotterySync_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lotteryType",
        .dataTypeSpecific.clazz = Nil,
        .number = LotterySync_Msg_FieldNumber_LotteryType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LotterySync_Msg__storage_, lotteryType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lotteryInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(LotterySync_LotteryInfo),
        .number = LotterySync_Msg_FieldNumber_LotteryInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LotterySync_Msg__storage_, lotteryInfo),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LotterySync_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LotterySync_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\013\000\005\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LotterySync)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendContactInfo

@implementation SendContactInfo

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct SendContactInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  SendContactInfo_Msg *msg;
} SendContactInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = SendContactInfo_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendContactInfo__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = SendContactInfo_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendContactInfo__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(SendContactInfo_Msg),
        .number = SendContactInfo_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendContactInfo__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendContactInfo class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendContactInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendContactInfo_Msg

@implementation SendContactInfo_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;

typedef struct SendContactInfo_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  NSString *ct;
} SendContactInfo_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = SendContactInfo_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendContactInfo_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = SendContactInfo_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendContactInfo_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = SendContactInfo_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendContactInfo_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendContactInfo_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendContactInfo_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SendContactInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendRed

@implementation SendRed

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct SendRed__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  SendRed_Msg *msg;
} SendRed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendRed__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendRed__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(SendRed_Msg),
        .number = SendRed_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendRed__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendRed class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendRed__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendRed_Msg

@implementation SendRed_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasTouid, touid;
@dynamic hasUgood, ugood;
@dynamic hasUid, uid;
@dynamic hasName, name;
@dynamic hasUname, uname;
@dynamic hasEquipment, equipment;
@dynamic hasRoomnum, roomnum;
@dynamic hasLevel, level;
@dynamic hasEvensend, evensend;
@dynamic hasUhead, uhead;
@dynamic hasVipType, vipType;
@dynamic hasLiangname, liangname;
@dynamic hasIsAnchor, isAnchor;

typedef struct SendRed_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t touid;
  uint32_t ugood;
  uint32_t uid;
  uint32_t roomnum;
  uint32_t level;
  uint32_t vipType;
  NSString *ct;
  NSString *name;
  NSString *uname;
  NSString *equipment;
  NSString *evensend;
  NSString *uhead;
  NSString *liangname;
} SendRed_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "touid",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Touid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, touid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ugood",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Ugood,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, ugood),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Uid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Name,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Uname,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, uname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "equipment",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Equipment,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, equipment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomnum",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Roomnum,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, roomnum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Level,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "evensend",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Evensend,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, evensend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uhead",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Uhead,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, uhead),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vipType",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_VipType,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, vipType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "liangname",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_Liangname,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(SendRed_Msg__storage_, liangname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAnchor",
        .dataTypeSpecific.clazz = Nil,
        .number = SendRed_Msg_FieldNumber_IsAnchor,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendRed_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendRed_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\020\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SendRed)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendGift

@implementation SendGift

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct SendGift__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  SendGift_Msg *msg;
} SendGift__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendGift__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendGift__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(SendGift_Msg),
        .number = SendGift_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendGift__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendGift class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendGift__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendGift_GiftInfo

@implementation SendGift_GiftInfo

@dynamic hasUid, uid;
@dynamic hasGiftid, giftid;
@dynamic hasType, type;
@dynamic hasGiftcount, giftcount;
@dynamic hasTotalcoin, totalcoin;
@dynamic hasGiftname, giftname;
@dynamic hasGifticon, gifticon;
@dynamic hasSwftime, swftime;
@dynamic hasSwftype, swftype;
@dynamic hasSwf, swf;
@dynamic hasLevel, level;
@dynamic hasCoin, coin;
@dynamic hasVotestotal, votestotal;
@dynamic hasStrvotestotal, strvotestotal;

typedef struct SendGift_GiftInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uid;
  uint32_t giftid;
  uint32_t type;
  uint32_t giftcount;
  uint32_t totalcoin;
  uint32_t swftime;
  uint32_t swftype;
  uint32_t level;
  uint32_t coin;
  uint32_t votestotal;
  NSString *giftname;
  NSString *gifticon;
  NSString *swf;
  NSString *strvotestotal;
} SendGift_GiftInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftid",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Giftid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, giftid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftcount",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Giftcount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, giftcount),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalcoin",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Totalcoin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, totalcoin),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftname",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Giftname,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, giftname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gifticon",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Gifticon,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, gifticon),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "swftime",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Swftime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, swftime),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "swftype",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Swftype,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, swftype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "swf",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Swf,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, swf),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Level,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, level),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "coin",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Coin,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, coin),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "votestotal",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Votestotal,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, votestotal),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "strvotestotal",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_GiftInfo_FieldNumber_Strvotestotal,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(SendGift_GiftInfo__storage_, strvotestotal),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendGift_GiftInfo class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendGift_GiftInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SendGift)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendGift_Msg

@implementation SendGift_Msg

@dynamic hasAction, action;
@dynamic hasCt, ct;
@dynamic hasMsgtype, msgtype;
@dynamic hasUid, uid;
@dynamic hasUname, uname;
@dynamic hasEquipment, equipment;
@dynamic hasRoomnum, roomnum;
@dynamic hasLevel, level;
@dynamic hasEvensend, evensend;
@dynamic hasUhead, uhead;
@dynamic hasVipType, vipType;
@dynamic hasLiangname, liangname;
@dynamic hasIfpk, ifpk;
@dynamic hasPkuid1, pkuid1;
@dynamic hasPkuid2, pkuid2;
@dynamic hasPktotal1, pktotal1;
@dynamic hasPktotal2, pktotal2;

typedef struct SendGift_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t uid;
  uint32_t roomnum;
  uint32_t level;
  uint32_t vipType;
  uint32_t ifpk;
  uint32_t pkuid1;
  uint32_t pkuid2;
  uint32_t pktotal1;
  uint32_t pktotal2;
  SendGift_GiftInfo *ct;
  NSString *uname;
  NSString *equipment;
  NSString *evensend;
  NSString *uhead;
  NSString *liangname;
} SendGift_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = GPBObjCClass(SendGift_GiftInfo),
        .number = SendGift_Msg_FieldNumber_Ct,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Msgtype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Uname,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, uname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "equipment",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Equipment,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, equipment),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomnum",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Roomnum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, roomnum),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Level,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, level),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "evensend",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Evensend,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, evensend),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uhead",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Uhead,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, uhead),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vipType",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_VipType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, vipType),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "liangname",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Liangname,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, liangname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ifpk",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Ifpk,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, ifpk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pkuid1",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Pkuid1,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, pkuid1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pkuid2",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Pkuid2,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, pkuid2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pktotal1",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Pktotal1,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, pktotal1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pktotal2",
        .dataTypeSpecific.clazz = Nil,
        .number = SendGift_Msg_FieldNumber_Pktotal2,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(SendGift_Msg__storage_, pktotal2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendGift_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendGift_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SendGift)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendBarrage

@implementation SendBarrage

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct SendBarrage__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  SendBarrage_Msg *msg;
} SendBarrage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendBarrage__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendBarrage__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(SendBarrage_Msg),
        .number = SendBarrage_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendBarrage__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendBarrage class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendBarrage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendBarrage_CTStruct

@implementation SendBarrage_CTStruct

@dynamic hasUid, uid;
@dynamic hasContent, content;
@dynamic hasGiftid, giftid;
@dynamic hasGiftcount, giftcount;
@dynamic hasTotalcoin, totalcoin;
@dynamic hasGiftname, giftname;
@dynamic hasGifticon, gifticon;
@dynamic hasLevel, level;
@dynamic hasCoin, coin;
@dynamic hasVotestotal, votestotal;
@dynamic hasStrvotestotal, strvotestotal;

typedef struct SendBarrage_CTStruct__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uid;
  uint32_t giftid;
  uint32_t giftcount;
  uint32_t totalcoin;
  uint32_t level;
  uint32_t coin;
  uint32_t votestotal;
  NSString *content;
  NSString *giftname;
  NSString *gifticon;
  NSString *strvotestotal;
} SendBarrage_CTStruct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, content),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "giftid",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Giftid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, giftid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftcount",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Giftcount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, giftcount),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalcoin",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Totalcoin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, totalcoin),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "giftname",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Giftname,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, giftname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gifticon",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Gifticon,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, gifticon),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Level,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, level),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "coin",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Coin,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, coin),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "votestotal",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Votestotal,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, votestotal),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "strvotestotal",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_CTStruct_FieldNumber_Strvotestotal,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(SendBarrage_CTStruct__storage_, strvotestotal),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendBarrage_CTStruct class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendBarrage_CTStruct__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SendBarrage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendBarrage_Msg

@implementation SendBarrage_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasLevel, level;
@dynamic hasUname, uname;
@dynamic hasUid, uid;
@dynamic hasUhead, uhead;
@dynamic hasCt, ct;

typedef struct SendBarrage_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t level;
  uint32_t uid;
  NSString *uname;
  NSString *uhead;
  SendBarrage_CTStruct *ct;
} SendBarrage_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendBarrage_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendBarrage_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_Msg_FieldNumber_Level,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendBarrage_Msg__storage_, level),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_Msg_FieldNumber_Uname,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendBarrage_Msg__storage_, uname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_Msg_FieldNumber_Uid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendBarrage_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uhead",
        .dataTypeSpecific.clazz = Nil,
        .number = SendBarrage_Msg_FieldNumber_Uhead,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendBarrage_Msg__storage_, uhead),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = GPBObjCClass(SendBarrage_CTStruct),
        .number = SendBarrage_Msg_FieldNumber_Ct,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendBarrage_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendBarrage_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendBarrage_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SendBarrage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - changeLive

@implementation changeLive

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct changeLive__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  changeLive_Msg *msg;
} changeLive__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = changeLive_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(changeLive__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = changeLive_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(changeLive__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(changeLive_Msg),
        .number = changeLive_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(changeLive__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[changeLive class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(changeLive__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - changeLive_Msg

@implementation changeLive_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasTypeVal, typeVal;
@dynamic hasType, type;
@dynamic hasRoomType, roomType;
@dynamic hasMsg, msg;

typedef struct changeLive_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  NSString *typeVal;
  NSString *type;
  NSString *roomType;
  NSString *msg;
} changeLive_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = changeLive_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(changeLive_Msg__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = changeLive_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(changeLive_Msg__storage_, msgtype),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "typeVal",
        .dataTypeSpecific.clazz = Nil,
        .number = changeLive_Msg_FieldNumber_TypeVal,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(changeLive_Msg__storage_, typeVal),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = changeLive_Msg_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(changeLive_Msg__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomType",
        .dataTypeSpecific.clazz = Nil,
        .number = changeLive_Msg_FieldNumber_RoomType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(changeLive_Msg__storage_, roomType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = Nil,
        .number = changeLive_Msg_FieldNumber_Msg,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(changeLive_Msg__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[changeLive_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(changeLive_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(changeLive)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - updateVotes

@implementation updateVotes

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct updateVotes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  updateVotes_Msg *msg;
} updateVotes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = updateVotes_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(updateVotes__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = updateVotes_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(updateVotes__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(updateVotes_Msg),
        .number = updateVotes_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(updateVotes__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[updateVotes class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(updateVotes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - updateVotes_Msg

@implementation updateVotes_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasVotes, votes;
@dynamic hasUid, uid;
@dynamic hasIsfirst, isfirst;
@dynamic hasStrvotestotal, strvotestotal;

typedef struct updateVotes_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  float votes;
  uint32_t uid;
  uint32_t isfirst;
  NSString *strvotestotal;
} updateVotes_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = updateVotes_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(updateVotes_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = updateVotes_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(updateVotes_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "votes",
        .dataTypeSpecific.clazz = Nil,
        .number = updateVotes_Msg_FieldNumber_Votes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(updateVotes_Msg__storage_, votes),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = updateVotes_Msg_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(updateVotes_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isfirst",
        .dataTypeSpecific.clazz = Nil,
        .number = updateVotes_Msg_FieldNumber_Isfirst,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(updateVotes_Msg__storage_, isfirst),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "strvotestotal",
        .dataTypeSpecific.clazz = Nil,
        .number = updateVotes_Msg_FieldNumber_Strvotestotal,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(updateVotes_Msg__storage_, strvotestotal),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[updateVotes_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(updateVotes_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(updateVotes)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShutUpUser

@implementation ShutUpUser

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct ShutUpUser__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  ShutUpUser_Msg *msg;
} ShutUpUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = ShutUpUser_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShutUpUser__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = ShutUpUser_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShutUpUser__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(ShutUpUser_Msg),
        .number = ShutUpUser_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShutUpUser__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShutUpUser class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShutUpUser__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShutUpUser_Msg

@implementation ShutUpUser_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasCt, ct;
@dynamic hasUid, uid;
@dynamic hasTouid, touid;

typedef struct ShutUpUser_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t uid;
  uint32_t touid;
  NSString *ct;
} ShutUpUser_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = ShutUpUser_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShutUpUser_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = ShutUpUser_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShutUpUser_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = ShutUpUser_Msg_FieldNumber_Ct,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShutUpUser_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = ShutUpUser_Msg_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShutUpUser_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "touid",
        .dataTypeSpecific.clazz = Nil,
        .number = ShutUpUser_Msg_FieldNumber_Touid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShutUpUser_Msg__storage_, touid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShutUpUser_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShutUpUser_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShutUpUser)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - setAdmin

@implementation setAdmin

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct setAdmin__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  setAdmin_Msg *msg;
} setAdmin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = setAdmin_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(setAdmin__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = setAdmin_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(setAdmin__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(setAdmin_Msg),
        .number = setAdmin_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(setAdmin__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[setAdmin class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(setAdmin__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - setAdmin_Msg

@implementation setAdmin_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasCt, ct;
@dynamic hasUid, uid;
@dynamic hasUname, uname;
@dynamic hasTouid, touid;
@dynamic hasTouname, touname;

typedef struct setAdmin_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t uid;
  uint32_t touid;
  NSString *ct;
  NSString *uname;
  NSString *touname;
} setAdmin_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = setAdmin_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(setAdmin_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = setAdmin_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(setAdmin_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = setAdmin_Msg_FieldNumber_Ct,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(setAdmin_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = setAdmin_Msg_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(setAdmin_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = setAdmin_Msg_FieldNumber_Uname,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(setAdmin_Msg__storage_, uname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "touid",
        .dataTypeSpecific.clazz = Nil,
        .number = setAdmin_Msg_FieldNumber_Touid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(setAdmin_Msg__storage_, touid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "touname",
        .dataTypeSpecific.clazz = Nil,
        .number = setAdmin_Msg_FieldNumber_Touname,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(setAdmin_Msg__storage_, touname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[setAdmin_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(setAdmin_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(setAdmin)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BuyGuard

@implementation BuyGuard

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct BuyGuard__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  BuyGuard_Msg *msg;
} BuyGuard__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuyGuard__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BuyGuard__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(BuyGuard_Msg),
        .number = BuyGuard_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BuyGuard__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuyGuard class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuyGuard__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BuyGuard_Msg

@implementation BuyGuard_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasCt, ct;
@dynamic hasUid, uid;
@dynamic hasUname, uname;
@dynamic hasUhead, uhead;
@dynamic hasVotestotal, votestotal;
@dynamic hasGuardNums, guardNums;
@dynamic hasGuardType, guardType;
@dynamic hasStrvotestotal, strvotestotal;

typedef struct BuyGuard_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t uid;
  uint32_t votestotal;
  uint32_t guardNums;
  uint32_t guardType;
  NSString *ct;
  NSString *uname;
  NSString *uhead;
  NSString *strvotestotal;
} BuyGuard_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_Ct,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, ct),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_Uname,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, uname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uhead",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_Uhead,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, uhead),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "votestotal",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_Votestotal,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, votestotal),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "guardNums",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_GuardNums,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, guardNums),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "guardType",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_GuardType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, guardType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "strvotestotal",
        .dataTypeSpecific.clazz = Nil,
        .number = BuyGuard_Msg_FieldNumber_Strvotestotal,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BuyGuard_Msg__storage_, strvotestotal),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuyGuard_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuyGuard_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(BuyGuard)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KickUser

@implementation KickUser

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct KickUser__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  KickUser_Msg *msg;
} KickUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUser_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KickUser__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUser_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KickUser__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(KickUser_Msg),
        .number = KickUser_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KickUser__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KickUser class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KickUser__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KickUser_Msg

@implementation KickUser_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasCt, ct;
@dynamic hasUid, uid;
@dynamic hasTouid, touid;
@dynamic hasShowid, showid;
@dynamic hasUname, uname;

typedef struct KickUser_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  uint32_t uid;
  uint32_t touid;
  uint32_t showid;
  NSString *ct;
  NSString *uname;
} KickUser_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUser_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KickUser_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUser_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KickUser_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUser_Msg_FieldNumber_Ct,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KickUser_Msg__storage_, ct),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUser_Msg_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(KickUser_Msg__storage_, uid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "touid",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUser_Msg_FieldNumber_Touid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(KickUser_Msg__storage_, touid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "showid",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUser_Msg_FieldNumber_Showid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(KickUser_Msg__storage_, showid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uname",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUser_Msg_FieldNumber_Uname,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(KickUser_Msg__storage_, uname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KickUser_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KickUser_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(KickUser)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - light

@implementation light

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct light__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  light_Msg *msg;
} light__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = light_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(light__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = light_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(light__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(light_Msg),
        .number = light_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(light__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[light class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(light__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - light_Msg

@implementation light_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;
@dynamic hasCt, ct;

typedef struct light_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
  NSString *ct;
} light_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = light_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(light_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = light_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(light_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ct",
        .dataTypeSpecific.clazz = Nil,
        .number = light_Msg_FieldNumber_Ct,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(light_Msg__storage_, ct),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[light_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(light_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(light)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - stopLive

@implementation stopLive

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct stopLive__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  stopLive_Msg *msg;
} stopLive__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = stopLive_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(stopLive__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = stopLive_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(stopLive__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(stopLive_Msg),
        .number = stopLive_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(stopLive__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[stopLive class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(stopLive__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - stopLive_Msg

@implementation stopLive_Msg

@dynamic hasAction, action;
@dynamic hasMsgtype, msgtype;

typedef struct stopLive_Msg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t action;
  uint32_t msgtype;
} stopLive_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = stopLive_Msg_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(stopLive_Msg__storage_, action),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgtype",
        .dataTypeSpecific.clazz = Nil,
        .number = stopLive_Msg_FieldNumber_Msgtype,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(stopLive_Msg__storage_, msgtype),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[stopLive_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(stopLive_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(stopLive)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppTopNotice

@implementation AppTopNotice

@dynamic hasRetcode, retcode;
@dynamic hasRetmsg, retmsg;
@dynamic hasMsg, msg;

typedef struct AppTopNotice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t retcode;
  NSString *retmsg;
  AppTopNotice_Msg *msg;
} AppTopNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retcode",
        .dataTypeSpecific.clazz = Nil,
        .number = AppTopNotice_FieldNumber_Retcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppTopNotice__storage_, retcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retmsg",
        .dataTypeSpecific.clazz = Nil,
        .number = AppTopNotice_FieldNumber_Retmsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppTopNotice__storage_, retmsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(AppTopNotice_Msg),
        .number = AppTopNotice_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppTopNotice__storage_, msg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppTopNotice class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppTopNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppTopNotice_Msg

@implementation AppTopNotice_Msg

@dynamic hasNoticeTitle, noticeTitle;
@dynamic hasNoticeMainIcon, noticeMainIcon;
@dynamic hasNoticeContent, noticeContent;
@dynamic hasNoticeSubIcon, noticeSubIcon;
@dynamic hasNoticeScheme, noticeScheme;

typedef struct AppTopNotice_Msg__storage_ {
  uint32_t _has_storage_[1];
  NSString *noticeTitle;
  NSString *noticeMainIcon;
  NSString *noticeContent;
  NSString *noticeSubIcon;
  NSString *noticeScheme;
} AppTopNotice_Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "noticeTitle",
        .dataTypeSpecific.clazz = Nil,
        .number = AppTopNotice_Msg_FieldNumber_NoticeTitle,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppTopNotice_Msg__storage_, noticeTitle),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noticeMainIcon",
        .dataTypeSpecific.clazz = Nil,
        .number = AppTopNotice_Msg_FieldNumber_NoticeMainIcon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppTopNotice_Msg__storage_, noticeMainIcon),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noticeContent",
        .dataTypeSpecific.clazz = Nil,
        .number = AppTopNotice_Msg_FieldNumber_NoticeContent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppTopNotice_Msg__storage_, noticeContent),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noticeSubIcon",
        .dataTypeSpecific.clazz = Nil,
        .number = AppTopNotice_Msg_FieldNumber_NoticeSubIcon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AppTopNotice_Msg__storage_, noticeSubIcon),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noticeScheme",
        .dataTypeSpecific.clazz = Nil,
        .number = AppTopNotice_Msg_FieldNumber_NoticeScheme,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AppTopNotice_Msg__storage_, noticeScheme),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppTopNotice_Msg class]
                                     rootClass:[S2CRoot class]
                                          file:S2CRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppTopNotice_Msg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(AppTopNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
